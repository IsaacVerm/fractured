## gotchas

### correct field type

It's important to choose the correct field type. E.g. [CharField](https://docs.djangoproject.com/en/3.0/ref/models/fields/#charfield) is used for short texts, [TextField](https://docs.djangoproject.com/en/3.0/ref/models/fields/#django.db.models.TextField) is used for longer texts.

### migrations

Migrating actually consists of 2 commands:

- `makemigrations`
- `migrate`

`makemigrations` means you want to turn the changes to your model into a migration. `migrate` reflects those migrations in the database.

For safety reasons you can run 2 commands:

- `sqlmigrate`
- `check`

`sqlmigrate` means you want to see what changes will be made in the database. This doesn't execute anything. `check` works like `devtools::check()` in R.

### meta database API

Next to the [database API](https://docs.djangoproject.com/en/3.0/topics/db/queries/) itself, there's also a [model meta API](https://docs.djangoproject.com/en/3.0/ref/models/meta/). You can use meta api to get for example all the fields defined in a model (with their type, ...). Within the Django shell:

```
Article._meta.get_fields()
```

### admin

Getting a fullblown admin interface for free is great. Only thing to do is register the models you want to be able to edit in `admin.py`.

Form automatically generated:

![django form autogenerated](/django-form-auto-generated.png)

### template namespacing

Template namespacing is weird because you end up with `/articles/templates/articles` but it's necessary because of the [way Django loads templates](https://docs.djangoproject.com/en/3.0/intro/tutorial03/).

### filter on model methods

[You can't filter on model methods](https://stackoverflow.com/questions/31658793/django-filter-query-on-with-property-fields-automatically-calculated). The correct way to filter is to use list comprehensions:

- first get all the results in the queryset
- filter manually with conditional statement like if

There's a solution as well where you add the result of the method as a field in the model. But this way the model becomes bloated. Queries are sent to the database so they can only filter on fields which exist in the database.

### code in templates

[There's no Python code in templates](https://docs.djangoproject.com/en/3.0/ref/templates/language/) although some stuff may have the same name (e.g. `for`).

### while implementing

Put calls to external API (rss feeds in our case) [in views function](https://simpleisbetterthancomplex.com/tutorial/2018/02/03/how-to-use-restful-apis-with-django.html).

`feedparser` doesn't work anymore because of [SSL certification issue](https://stackoverflow.com/questions/28282797/feedparser-parse-ssl-certificate-verify-failed).

Must use `{% csrf_token %}` for [CSRF errors](https://docs.djangoproject.com/en/3.0/intro/tutorial04/).

Use `reverse` not to hardcode urls in templates. Maybe not so important since the app is still small. Make issue in Github.

Proper url management is key.

Use [repath](https://docs.djangoproject.com/en/3.0/topics/http/urls/) to make distinction between `<article_path>` and save.

Issue: reusable functions between views. E.g. clean article_path involved removing `de standaard blabla`.

Working with forms can be made easier by using the [Form](https://docs.djangoproject.com/en/3.0/topics/forms/#the-view) class.

Hack: hidden `input` element prefilled with description data. Probably not the proper way to pass data between contexts and views.

Multiple forms so at least one form is empty results in [multivalue dict key errors](https://stackoverflow.com/questions/5895588/django-multivaluedictkeyerror-error-how-do-i-deal-with-it).

### sending mails

Sending mails itself is [well documented and easy](https://docs.djangoproject.com/en/3.0/topics/email/).

To send mails you have to provide your password. Checking this password in to GitHub is naturally not a good idea since it's there for everyone to see. You can set up [environment variables](https://stackoverflow.com/questions/55640495/django-send-mail-security-password) which are injected at runtime. Environment variables in Python are set [this way](https://djangostars.com/blog/configuring-django-settings-best-practices/).

### css

button as hyperlink is [hard](https://www.w3docs.com/snippets/html/how-to-create-an-html-button-that-acts-like-a-link.html). Played around with `input` from form. Settled for a button in the end.

## Cypress

Now we've got the mimimum of an app set up, it's time to set up the testing. I chose to have the tests in the same repository as the web app. Figured I can always split it off in a separate repo later on if the need might arise. Also opens possibility of [watching app file changes](https://github.com/bahmutov/cypress-watch-and-reload).

Important to test [font size](https://kyleschaeffer.com/css-font-size-em-vs-px-vs-pt-vs-percent) for elderly.

Data has to be [seeded](https://docs.djangoproject.com/en/2.2/howto/initial-data/).

## Travis

### notes

We can only test against a running server. At first I tried to have 2 separate jobs:

- a python job running a local version of the web server
- node job with tests against this local web server

Somehow this worked. I have no idea why the current setup works. Python process serving the Django server should never finish so the Cypress tests shouldn't run in the job just afterwards. But after some time the tests do start to run.

Sadly discovered the node job has access to the local web server. So I moved to a different approach:

- first deploy to Heroku
- then run tests on Travis against this deployed Heroku version

So there's no longer any need for build matrices, ...

That's why the latest changes are first deployed to Heroku as explained [here](https://docs.travis-ci.com/user/deployment/heroku/).

Travis can only handle [single commands or scripts](https://docs.travis-ci.com/user/deployment/script/).

You can run multiple languages [in the same Travis config](https://stackoverflow.com/questions/27644586/how-to-set-up-travis-ci-with-multiple-languages).

Difference between [build matrix](https://docs.travis-ci.com/user/build-matrix/) and [build stages](https://docs.travis-ci.com/user/build-stages/) is the order. Jobs in the build matrix run in parallel while those in build stages run sequentially.

Travis still fails, but because it doesn't share the web server between jobs. Didn't find a easy way to make this possible. Maybe best way is to move on to Heroku deployment, deploy the web app to a test environment and just then run the tests.

### pays off fast

Since on every push to Github the tests ran, you immediately get notified if something goes wrong. Even if you think nothing could have gone wrong. Good catch was this commit where I [forgot to add](https://github.com/IsaacVerm/easy-newspapers/commit/7274eb501312c2ba80b6cee2608b5f25377438c5) one of the installed packages to `requirements.txt`. The app broke down and I could immediately handle the issue. If I would have continued developing I wouldn't have noticed anything (since I do have `atoma` locally!). Untangling the mess surely would have taken some time.

## Heroku

Interesting [explanation by Mozilla](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Deployment) how to deploy Heroku.

Heroku provides a library [helping with deploying Django apps](https://github.com/heroku/django-heroku).

You should install `gunicorn` if you wan't to deploy (but not needed when deployed).

We can't use the default SQLite database on Heroku because it is file-based, and it would be deleted from the ephemeral file system every time the application restarts (typically once a day, and every time the application or its configuration variables are changed).

The Heroku mechanism for handling this situation is to use a database add-on and configure the web application using information from an environment configuration variable, set by the add-on.

[Github] Django template.
